{
  "version": 3,
  "sources": ["../node_modules/idiomorph/dist/idiomorph.esm.js", "../src/razorx.ts"],
  "sourcesContent": ["/**\n * @typedef {object} ConfigHead\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} [style]\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {function(Element): boolean} [shouldPreserve]\n * @property {function(Element): boolean} [shouldReAppend]\n * @property {function(Element): boolean} [shouldRemove]\n * @property {function(Element, {added: Node[], kept: Element[], removed: Element[]}): void} [afterHeadMorphed]\n */\n\n/**\n * @typedef {object} ConfigCallbacks\n *\n * @property {function(Node): boolean} [beforeNodeAdded]\n * @property {function(Node): void} [afterNodeAdded]\n * @property {function(Element, Node): boolean} [beforeNodeMorphed]\n * @property {function(Element, Node): void} [afterNodeMorphed]\n * @property {function(Element): boolean} [beforeNodeRemoved]\n * @property {function(Element): void} [afterNodeRemoved]\n * @property {function(string, Element, \"update\" | \"remove\"): boolean} [beforeAttributeUpdated]\n */\n\n/**\n * @typedef {object} Config\n *\n * @property {'outerHTML' | 'innerHTML'} [morphStyle]\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {boolean} [restoreFocus]\n * @property {ConfigCallbacks} [callbacks]\n * @property {ConfigHead} [head]\n */\n\n/**\n * @typedef {function} NoOp\n *\n * @returns {void}\n */\n\n/**\n * @typedef {object} ConfigHeadInternal\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} style\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {(function(Element): boolean) | NoOp} shouldPreserve\n * @property {(function(Element): boolean) | NoOp} shouldReAppend\n * @property {(function(Element): boolean) | NoOp} shouldRemove\n * @property {(function(Element, {added: Node[], kept: Element[], removed: Element[]}): void) | NoOp} afterHeadMorphed\n */\n\n/**\n * @typedef {object} ConfigCallbacksInternal\n *\n * @property {(function(Node): boolean) | NoOp} beforeNodeAdded\n * @property {(function(Node): void) | NoOp} afterNodeAdded\n * @property {(function(Node, Node): boolean) | NoOp} beforeNodeMorphed\n * @property {(function(Node, Node): void) | NoOp} afterNodeMorphed\n * @property {(function(Node): boolean) | NoOp} beforeNodeRemoved\n * @property {(function(Node): void) | NoOp} afterNodeRemoved\n * @property {(function(string, Element, \"update\" | \"remove\"): boolean) | NoOp} beforeAttributeUpdated\n */\n\n/**\n * @typedef {object} ConfigInternal\n *\n * @property {'outerHTML' | 'innerHTML'} morphStyle\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {boolean} [restoreFocus]\n * @property {ConfigCallbacksInternal} callbacks\n * @property {ConfigHeadInternal} head\n */\n\n/**\n * @typedef {Object} IdSets\n * @property {Set<string>} persistentIds\n * @property {Map<Node, Set<string>>} idMap\n */\n\n/**\n * @typedef {Function} Morph\n *\n * @param {Element | Document} oldNode\n * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n * @param {Config} [config]\n * @returns {undefined | Node[]}\n */\n\n// base IIFE to define idiomorph\n/**\n *\n * @type {{defaults: ConfigInternal, morph: Morph}}\n */\nvar Idiomorph = (function () {\n  \"use strict\";\n\n  /**\n   * @typedef {object} MorphContext\n   *\n   * @property {Element} target\n   * @property {Element} newContent\n   * @property {ConfigInternal} config\n   * @property {ConfigInternal['morphStyle']} morphStyle\n   * @property {ConfigInternal['ignoreActive']} ignoreActive\n   * @property {ConfigInternal['ignoreActiveValue']} ignoreActiveValue\n   * @property {ConfigInternal['restoreFocus']} restoreFocus\n   * @property {Map<Node, Set<string>>} idMap\n   * @property {Set<string>} persistentIds\n   * @property {ConfigInternal['callbacks']} callbacks\n   * @property {ConfigInternal['head']} head\n   * @property {HTMLDivElement} pantry\n   */\n\n  //=============================================================================\n  // AND NOW IT BEGINS...\n  //=============================================================================\n\n  const noOp = () => {};\n  /**\n   * Default configuration values, updatable by users now\n   * @type {ConfigInternal}\n   */\n  const defaults = {\n    morphStyle: \"outerHTML\",\n    callbacks: {\n      beforeNodeAdded: noOp,\n      afterNodeAdded: noOp,\n      beforeNodeMorphed: noOp,\n      afterNodeMorphed: noOp,\n      beforeNodeRemoved: noOp,\n      afterNodeRemoved: noOp,\n      beforeAttributeUpdated: noOp,\n    },\n    head: {\n      style: \"merge\",\n      shouldPreserve: (elt) => elt.getAttribute(\"im-preserve\") === \"true\",\n      shouldReAppend: (elt) => elt.getAttribute(\"im-re-append\") === \"true\",\n      shouldRemove: noOp,\n      afterHeadMorphed: noOp,\n    },\n    restoreFocus: true,\n  };\n\n  /**\n   * Core idiomorph function for morphing one DOM tree to another\n   *\n   * @param {Element | Document} oldNode\n   * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n   * @param {Config} [config]\n   * @returns {Promise<Node[]> | Node[]}\n   */\n  function morph(oldNode, newContent, config = {}) {\n    oldNode = normalizeElement(oldNode);\n    const newNode = normalizeParent(newContent);\n    const ctx = createMorphContext(oldNode, newNode, config);\n\n    const morphedNodes = saveAndRestoreFocus(ctx, () => {\n      return withHeadBlocking(\n        ctx,\n        oldNode,\n        newNode,\n        /** @param {MorphContext} ctx */ (ctx) => {\n          if (ctx.morphStyle === \"innerHTML\") {\n            morphChildren(ctx, oldNode, newNode);\n            return Array.from(oldNode.childNodes);\n          } else {\n            return morphOuterHTML(ctx, oldNode, newNode);\n          }\n        },\n      );\n    });\n\n    ctx.pantry.remove();\n    return morphedNodes;\n  }\n\n  /**\n   * Morph just the outerHTML of the oldNode to the newContent\n   * We have to be careful because the oldNode could have siblings which need to be untouched\n   * @param {MorphContext} ctx\n   * @param {Element} oldNode\n   * @param {Element} newNode\n   * @returns {Node[]}\n   */\n  function morphOuterHTML(ctx, oldNode, newNode) {\n    const oldParent = normalizeParent(oldNode);\n    morphChildren(\n      ctx,\n      oldParent,\n      newNode,\n      // these two optional params are the secret sauce\n      oldNode, // start point for iteration\n      oldNode.nextSibling, // end point for iteration\n    );\n    // this is safe even with siblings, because normalizeParent returns a SlicedParentNode if needed.\n    return Array.from(oldParent.childNodes);\n  }\n\n  /**\n   * @param {MorphContext} ctx\n   * @param {Function} fn\n   * @returns {Promise<Node[]> | Node[]}\n   */\n  function saveAndRestoreFocus(ctx, fn) {\n    if (!ctx.config.restoreFocus) return fn();\n    let activeElement =\n      /** @type {HTMLInputElement|HTMLTextAreaElement|null} */ (\n        document.activeElement\n      );\n\n    // don't bother if the active element is not an input or textarea\n    if (\n      !(\n        activeElement instanceof HTMLInputElement ||\n        activeElement instanceof HTMLTextAreaElement\n      )\n    ) {\n      return fn();\n    }\n\n    const { id: activeElementId, selectionStart, selectionEnd } = activeElement;\n\n    const results = fn();\n\n    if (activeElementId && activeElementId !== document.activeElement?.id) {\n      activeElement = ctx.target.querySelector(`[id=\"${activeElementId}\"]`);\n      activeElement?.focus();\n    }\n    if (activeElement && !activeElement.selectionEnd && selectionEnd) {\n      activeElement.setSelectionRange(selectionStart, selectionEnd);\n    }\n\n    return results;\n  }\n\n  const morphChildren = (function () {\n    /**\n     * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n     * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n     * by using id sets, we are able to better match up with content deeper in the DOM.\n     *\n     * Basic algorithm:\n     * - for each node in the new content:\n     *   - search self and siblings for an id set match, falling back to a soft match\n     *   - if match found\n     *     - remove any nodes up to the match:\n     *       - pantry persistent nodes\n     *       - delete the rest\n     *     - morph the match\n     *   - elsif no match found, and node is persistent\n     *     - find its match by querying the old root (future) and pantry (past)\n     *     - move it and its children here\n     *     - morph it\n     *   - else\n     *     - create a new node from scratch as a last result\n     *\n     * @param {MorphContext} ctx the merge context\n     * @param {Element} oldParent the old content that we are merging the new content into\n     * @param {Element} newParent the parent element of the new content\n     * @param {Node|null} [insertionPoint] the point in the DOM we start morphing at (defaults to first child)\n     * @param {Node|null} [endPoint] the point in the DOM we stop morphing at (defaults to after last child)\n     */\n    function morphChildren(\n      ctx,\n      oldParent,\n      newParent,\n      insertionPoint = null,\n      endPoint = null,\n    ) {\n      // normalize\n      if (\n        oldParent instanceof HTMLTemplateElement &&\n        newParent instanceof HTMLTemplateElement\n      ) {\n        // @ts-ignore we can pretend the DocumentFragment is an Element\n        oldParent = oldParent.content;\n        // @ts-ignore ditto\n        newParent = newParent.content;\n      }\n      insertionPoint ||= oldParent.firstChild;\n\n      // run through all the new content\n      for (const newChild of newParent.childNodes) {\n        // once we reach the end of the old parent content skip to the end and insert the rest\n        if (insertionPoint && insertionPoint != endPoint) {\n          const bestMatch = findBestMatch(\n            ctx,\n            newChild,\n            insertionPoint,\n            endPoint,\n          );\n          if (bestMatch) {\n            // if the node to morph is not at the insertion point then remove/move up to it\n            if (bestMatch !== insertionPoint) {\n              removeNodesBetween(ctx, insertionPoint, bestMatch);\n            }\n            morphNode(bestMatch, newChild, ctx);\n            insertionPoint = bestMatch.nextSibling;\n            continue;\n          }\n        }\n\n        // if the matching node is elsewhere in the original content\n        if (newChild instanceof Element && ctx.persistentIds.has(newChild.id)) {\n          // move it and all its children here and morph\n          const movedChild = moveBeforeById(\n            oldParent,\n            newChild.id,\n            insertionPoint,\n            ctx,\n          );\n          morphNode(movedChild, newChild, ctx);\n          insertionPoint = movedChild.nextSibling;\n          continue;\n        }\n\n        // last resort: insert the new node from scratch\n        const insertedNode = createNode(\n          oldParent,\n          newChild,\n          insertionPoint,\n          ctx,\n        );\n        // could be null if beforeNodeAdded prevented insertion\n        if (insertedNode) {\n          insertionPoint = insertedNode.nextSibling;\n        }\n      }\n\n      // remove any remaining old nodes that didn't match up with new content\n      while (insertionPoint && insertionPoint != endPoint) {\n        const tempNode = insertionPoint;\n        insertionPoint = insertionPoint.nextSibling;\n        removeNode(ctx, tempNode);\n      }\n    }\n\n    /**\n     * This performs the action of inserting a new node while handling situations where the node contains\n     * elements with persistent ids and possible state info we can still preserve by moving in and then morphing\n     *\n     * @param {Element} oldParent\n     * @param {Node} newChild\n     * @param {Node|null} insertionPoint\n     * @param {MorphContext} ctx\n     * @returns {Node|null}\n     */\n    function createNode(oldParent, newChild, insertionPoint, ctx) {\n      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return null;\n      if (ctx.idMap.has(newChild)) {\n        // node has children with ids with possible state so create a dummy elt of same type and apply full morph algorithm\n        const newEmptyChild = document.createElement(\n          /** @type {Element} */ (newChild).tagName,\n        );\n        oldParent.insertBefore(newEmptyChild, insertionPoint);\n        morphNode(newEmptyChild, newChild, ctx);\n        ctx.callbacks.afterNodeAdded(newEmptyChild);\n        return newEmptyChild;\n      } else {\n        // optimisation: no id state to preserve so we can just insert a clone of the newChild and its descendants\n        const newClonedChild = document.importNode(newChild, true); // importNode to not mutate newParent\n        oldParent.insertBefore(newClonedChild, insertionPoint);\n        ctx.callbacks.afterNodeAdded(newClonedChild);\n        return newClonedChild;\n      }\n    }\n\n    //=============================================================================\n    // Matching Functions\n    //=============================================================================\n    const findBestMatch = (function () {\n      /**\n       * Scans forward from the startPoint to the endPoint looking for a match\n       * for the node. It looks for an id set match first, then a soft match.\n       * We abort softmatching if we find two future soft matches, to reduce churn.\n       * @param {Node} node\n       * @param {MorphContext} ctx\n       * @param {Node | null} startPoint\n       * @param {Node | null} endPoint\n       * @returns {Node | null}\n       */\n      function findBestMatch(ctx, node, startPoint, endPoint) {\n        let softMatch = null;\n        let nextSibling = node.nextSibling;\n        let siblingSoftMatchCount = 0;\n\n        let cursor = startPoint;\n        while (cursor && cursor != endPoint) {\n          // soft matching is a prerequisite for id set matching\n          if (isSoftMatch(cursor, node)) {\n            if (isIdSetMatch(ctx, cursor, node)) {\n              return cursor; // found an id set match, we're done!\n            }\n\n            // we haven't yet saved a soft match fallback\n            if (softMatch === null) {\n              // the current soft match will hard match something else in the future, leave it\n              if (!ctx.idMap.has(cursor)) {\n                // save this as the fallback if we get through the loop without finding a hard match\n                softMatch = cursor;\n              }\n            }\n          }\n          if (\n            softMatch === null &&\n            nextSibling &&\n            isSoftMatch(cursor, nextSibling)\n          ) {\n            // The next new node has a soft match with this node, so\n            // increment the count of future soft matches\n            siblingSoftMatchCount++;\n            nextSibling = nextSibling.nextSibling;\n\n            // If there are two future soft matches, block soft matching for this node to allow\n            // future siblings to soft match. This is to reduce churn in the DOM when an element\n            // is prepended.\n            if (siblingSoftMatchCount >= 2) {\n              softMatch = undefined;\n            }\n          }\n\n          // if the current node contains active element, stop looking for better future matches,\n          // because if one is found, this node will be moved to the pantry, reparenting it and thus losing focus\n          if (cursor.contains(document.activeElement)) break;\n\n          cursor = cursor.nextSibling;\n        }\n\n        return softMatch || null;\n      }\n\n      /**\n       *\n       * @param {MorphContext} ctx\n       * @param {Node} oldNode\n       * @param {Node} newNode\n       * @returns {boolean}\n       */\n      function isIdSetMatch(ctx, oldNode, newNode) {\n        let oldSet = ctx.idMap.get(oldNode);\n        let newSet = ctx.idMap.get(newNode);\n\n        if (!newSet || !oldSet) return false;\n\n        for (const id of oldSet) {\n          // a potential match is an id in the new and old nodes that\n          // has not already been merged into the DOM\n          // But the newNode content we call this on has not been\n          // merged yet and we don't allow duplicate IDs so it is simple\n          if (newSet.has(id)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      /**\n       *\n       * @param {Node} oldNode\n       * @param {Node} newNode\n       * @returns {boolean}\n       */\n      function isSoftMatch(oldNode, newNode) {\n        // ok to cast: if one is not element, `id` and `tagName` will be undefined and we'll just compare that.\n        const oldElt = /** @type {Element} */ (oldNode);\n        const newElt = /** @type {Element} */ (newNode);\n\n        return (\n          oldElt.nodeType === newElt.nodeType &&\n          oldElt.tagName === newElt.tagName &&\n          // If oldElt has an `id` with possible state and it doesn't match newElt.id then avoid morphing.\n          // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,\n          // its not persistent, and new nodes can't have any hidden state.\n          (!oldElt.id || oldElt.id === newElt.id)\n        );\n      }\n\n      return findBestMatch;\n    })();\n\n    //=============================================================================\n    // DOM Manipulation Functions\n    //=============================================================================\n\n    /**\n     * Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:\n     * - Persistent nodes will be moved to the pantry for later reuse\n     * - Other nodes will have their hooks called, and then are removed\n     * @param {MorphContext} ctx\n     * @param {Node} node\n     */\n    function removeNode(ctx, node) {\n      // are we going to id set match this later?\n      if (ctx.idMap.has(node)) {\n        // skip callbacks and move to pantry\n        moveBefore(ctx.pantry, node, null);\n      } else {\n        // remove for realsies\n        if (ctx.callbacks.beforeNodeRemoved(node) === false) return;\n        node.parentNode?.removeChild(node);\n        ctx.callbacks.afterNodeRemoved(node);\n      }\n    }\n\n    /**\n     * Remove nodes between the start and end nodes\n     * @param {MorphContext} ctx\n     * @param {Node} startInclusive\n     * @param {Node} endExclusive\n     * @returns {Node|null}\n     */\n    function removeNodesBetween(ctx, startInclusive, endExclusive) {\n      /** @type {Node | null} */\n      let cursor = startInclusive;\n      // remove nodes until the endExclusive node\n      while (cursor && cursor !== endExclusive) {\n        let tempNode = /** @type {Node} */ (cursor);\n        cursor = cursor.nextSibling;\n        removeNode(ctx, tempNode);\n      }\n      return cursor;\n    }\n\n    /**\n     * Search for an element by id within the document and pantry, and move it using moveBefore.\n     *\n     * @param {Element} parentNode - The parent node to which the element will be moved.\n     * @param {string} id - The ID of the element to be moved.\n     * @param {Node | null} after - The reference node to insert the element before.\n     *                              If `null`, the element is appended as the last child.\n     * @param {MorphContext} ctx\n     * @returns {Element} The found element\n     */\n    function moveBeforeById(parentNode, id, after, ctx) {\n      const target =\n        /** @type {Element} - will always be found */\n        (\n          (ctx.target.id === id && ctx.target) ||\n            ctx.target.querySelector(`[id=\"${id}\"]`) ||\n            ctx.pantry.querySelector(`[id=\"${id}\"]`)\n        );\n      removeElementFromAncestorsIdMaps(target, ctx);\n      moveBefore(parentNode, target, after);\n      return target;\n    }\n\n    /**\n     * Removes an element from its ancestors' id maps. This is needed when an element is moved from the\n     * \"future\" via `moveBeforeId`. Otherwise, its erstwhile ancestors could be mistakenly moved to the\n     * pantry rather than being deleted, preventing their removal hooks from being called.\n     *\n     * @param {Element} element - element to remove from its ancestors' id maps\n     * @param {MorphContext} ctx\n     */\n    function removeElementFromAncestorsIdMaps(element, ctx) {\n      const id = element.id;\n      /** @ts-ignore - safe to loop in this way **/\n      while ((element = element.parentNode)) {\n        let idSet = ctx.idMap.get(element);\n        if (idSet) {\n          idSet.delete(id);\n          if (!idSet.size) {\n            ctx.idMap.delete(element);\n          }\n        }\n      }\n    }\n\n    /**\n     * Moves an element before another element within the same parent.\n     * Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.\n     * This is essentialy a forward-compat wrapper.\n     *\n     * @param {Element} parentNode - The parent node containing the after element.\n     * @param {Node} element - The element to be moved.\n     * @param {Node | null} after - The reference node to insert `element` before.\n     *                              If `null`, `element` is appended as the last child.\n     */\n    function moveBefore(parentNode, element, after) {\n      // @ts-ignore - use proposed moveBefore feature\n      if (parentNode.moveBefore) {\n        try {\n          // @ts-ignore - use proposed moveBefore feature\n          parentNode.moveBefore(element, after);\n        } catch (e) {\n          // fall back to insertBefore as some browsers may fail on moveBefore when trying to move Dom disconnected nodes to pantry\n          parentNode.insertBefore(element, after);\n        }\n      } else {\n        parentNode.insertBefore(element, after);\n      }\n    }\n\n    return morphChildren;\n  })();\n\n  //=============================================================================\n  // Single Node Morphing Code\n  //=============================================================================\n  const morphNode = (function () {\n    /**\n     * @param {Node} oldNode root node to merge content into\n     * @param {Node} newContent new content to merge\n     * @param {MorphContext} ctx the merge context\n     * @returns {Node | null} the element that ended up in the DOM\n     */\n    function morphNode(oldNode, newContent, ctx) {\n      if (ctx.ignoreActive && oldNode === document.activeElement) {\n        // don't morph focused element\n        return null;\n      }\n\n      if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) {\n        return oldNode;\n      }\n\n      if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n        // ignore the head element\n      } else if (\n        oldNode instanceof HTMLHeadElement &&\n        ctx.head.style !== \"morph\"\n      ) {\n        // ok to cast: if newContent wasn't also a <head>, it would've got caught in the `!isSoftMatch` branch above\n        handleHeadElement(\n          oldNode,\n          /** @type {HTMLHeadElement} */ (newContent),\n          ctx,\n        );\n      } else {\n        morphAttributes(oldNode, newContent, ctx);\n        if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n          // @ts-ignore newContent can be a node here because .firstChild will be null\n          morphChildren(ctx, oldNode, newContent);\n        }\n      }\n      ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n      return oldNode;\n    }\n\n    /**\n     * syncs the oldNode to the newNode, copying over all attributes and\n     * inner element state from the newNode to the oldNode\n     *\n     * @param {Node} oldNode the node to copy attributes & state to\n     * @param {Node} newNode the node to copy attributes & state from\n     * @param {MorphContext} ctx the merge context\n     */\n    function morphAttributes(oldNode, newNode, ctx) {\n      let type = newNode.nodeType;\n\n      // if is an element type, sync the attributes from the\n      // new node into the new node\n      if (type === 1 /* element type */) {\n        const oldElt = /** @type {Element} */ (oldNode);\n        const newElt = /** @type {Element} */ (newNode);\n\n        const oldAttributes = oldElt.attributes;\n        const newAttributes = newElt.attributes;\n        for (const newAttribute of newAttributes) {\n          if (ignoreAttribute(newAttribute.name, oldElt, \"update\", ctx)) {\n            continue;\n          }\n          if (oldElt.getAttribute(newAttribute.name) !== newAttribute.value) {\n            oldElt.setAttribute(newAttribute.name, newAttribute.value);\n          }\n        }\n        // iterate backwards to avoid skipping over items when a delete occurs\n        for (let i = oldAttributes.length - 1; 0 <= i; i--) {\n          const oldAttribute = oldAttributes[i];\n\n          // toAttributes is a live NamedNodeMap, so iteration+mutation is unsafe\n          // e.g. custom element attribute callbacks can remove other attributes\n          if (!oldAttribute) continue;\n\n          if (!newElt.hasAttribute(oldAttribute.name)) {\n            if (ignoreAttribute(oldAttribute.name, oldElt, \"remove\", ctx)) {\n              continue;\n            }\n            oldElt.removeAttribute(oldAttribute.name);\n          }\n        }\n\n        if (!ignoreValueOfActiveElement(oldElt, ctx)) {\n          syncInputValue(oldElt, newElt, ctx);\n        }\n      }\n\n      // sync text nodes\n      if (type === 8 /* comment */ || type === 3 /* text */) {\n        if (oldNode.nodeValue !== newNode.nodeValue) {\n          oldNode.nodeValue = newNode.nodeValue;\n        }\n      }\n    }\n\n    /**\n     * NB: many bothans died to bring us information:\n     *\n     *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n     *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n     *\n     * @param {Element} oldElement the element to sync the input value to\n     * @param {Element} newElement the element to sync the input value from\n     * @param {MorphContext} ctx the merge context\n     */\n    function syncInputValue(oldElement, newElement, ctx) {\n      if (\n        oldElement instanceof HTMLInputElement &&\n        newElement instanceof HTMLInputElement &&\n        newElement.type !== \"file\"\n      ) {\n        let newValue = newElement.value;\n        let oldValue = oldElement.value;\n\n        // sync boolean attributes\n        syncBooleanAttribute(oldElement, newElement, \"checked\", ctx);\n        syncBooleanAttribute(oldElement, newElement, \"disabled\", ctx);\n\n        if (!newElement.hasAttribute(\"value\")) {\n          if (!ignoreAttribute(\"value\", oldElement, \"remove\", ctx)) {\n            oldElement.value = \"\";\n            oldElement.removeAttribute(\"value\");\n          }\n        } else if (oldValue !== newValue) {\n          if (!ignoreAttribute(\"value\", oldElement, \"update\", ctx)) {\n            oldElement.setAttribute(\"value\", newValue);\n            oldElement.value = newValue;\n          }\n        }\n        // TODO: QUESTION(1cg): this used to only check `newElement` unlike the other branches -- why?\n        // did I break something?\n      } else if (\n        oldElement instanceof HTMLOptionElement &&\n        newElement instanceof HTMLOptionElement\n      ) {\n        syncBooleanAttribute(oldElement, newElement, \"selected\", ctx);\n      } else if (\n        oldElement instanceof HTMLTextAreaElement &&\n        newElement instanceof HTMLTextAreaElement\n      ) {\n        let newValue = newElement.value;\n        let oldValue = oldElement.value;\n        if (ignoreAttribute(\"value\", oldElement, \"update\", ctx)) {\n          return;\n        }\n        if (newValue !== oldValue) {\n          oldElement.value = newValue;\n        }\n        if (\n          oldElement.firstChild &&\n          oldElement.firstChild.nodeValue !== newValue\n        ) {\n          oldElement.firstChild.nodeValue = newValue;\n        }\n      }\n    }\n\n    /**\n     * @param {Element} oldElement element to write the value to\n     * @param {Element} newElement element to read the value from\n     * @param {string} attributeName the attribute name\n     * @param {MorphContext} ctx the merge context\n     */\n    function syncBooleanAttribute(oldElement, newElement, attributeName, ctx) {\n      // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n      const newLiveValue = newElement[attributeName],\n        // @ts-ignore ditto\n        oldLiveValue = oldElement[attributeName];\n      if (newLiveValue !== oldLiveValue) {\n        const ignoreUpdate = ignoreAttribute(\n          attributeName,\n          oldElement,\n          \"update\",\n          ctx,\n        );\n        if (!ignoreUpdate) {\n          // update attribute's associated DOM property\n          // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n          oldElement[attributeName] = newElement[attributeName];\n        }\n        if (newLiveValue) {\n          if (!ignoreUpdate) {\n            // https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML\n            // this is the correct way to set a boolean attribute to \"true\"\n            oldElement.setAttribute(attributeName, \"\");\n          }\n        } else {\n          if (!ignoreAttribute(attributeName, oldElement, \"remove\", ctx)) {\n            oldElement.removeAttribute(attributeName);\n          }\n        }\n      }\n    }\n\n    /**\n     * @param {string} attr the attribute to be mutated\n     * @param {Element} element the element that is going to be updated\n     * @param {\"update\" | \"remove\"} updateType\n     * @param {MorphContext} ctx the merge context\n     * @returns {boolean} true if the attribute should be ignored, false otherwise\n     */\n    function ignoreAttribute(attr, element, updateType, ctx) {\n      if (\n        attr === \"value\" &&\n        ctx.ignoreActiveValue &&\n        element === document.activeElement\n      ) {\n        return true;\n      }\n      return (\n        ctx.callbacks.beforeAttributeUpdated(attr, element, updateType) ===\n        false\n      );\n    }\n\n    /**\n     * @param {Node} possibleActiveElement\n     * @param {MorphContext} ctx\n     * @returns {boolean}\n     */\n    function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n      return (\n        !!ctx.ignoreActiveValue &&\n        possibleActiveElement === document.activeElement &&\n        possibleActiveElement !== document.body\n      );\n    }\n\n    return morphNode;\n  })();\n\n  //=============================================================================\n  // Head Management Functions\n  //=============================================================================\n  /**\n   * @param {MorphContext} ctx\n   * @param {Element} oldNode\n   * @param {Element} newNode\n   * @param {function} callback\n   * @returns {Node[] | Promise<Node[]>}\n   */\n  function withHeadBlocking(ctx, oldNode, newNode, callback) {\n    if (ctx.head.block) {\n      const oldHead = oldNode.querySelector(\"head\");\n      const newHead = newNode.querySelector(\"head\");\n      if (oldHead && newHead) {\n        const promises = handleHeadElement(oldHead, newHead, ctx);\n        // when head promises resolve, proceed ignoring the head tag\n        return Promise.all(promises).then(() => {\n          const newCtx = Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true,\n            },\n          });\n          return callback(newCtx);\n        });\n      }\n    }\n    // just proceed if we not head blocking\n    return callback(ctx);\n  }\n\n  /**\n   *  The HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n   *\n   * @param {Element} oldHead\n   * @param {Element} newHead\n   * @param {MorphContext} ctx\n   * @returns {Promise<void>[]}\n   */\n  function handleHeadElement(oldHead, newHead, ctx) {\n    let added = [];\n    let removed = [];\n    let preserved = [];\n    let nodesToAppend = [];\n\n    // put all new head elements into a Map, by their outerHTML\n    let srcToNewHeadNodes = new Map();\n    for (const newHeadChild of newHead.children) {\n      srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n    }\n\n    // for each elt in the current head\n    for (const currentHeadElt of oldHead.children) {\n      // If the current head element is in the map\n      let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n      let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n      let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n      if (inNewContent || isPreserved) {\n        if (isReAppended) {\n          // remove the current version and let the new version replace it and re-execute\n          removed.push(currentHeadElt);\n        } else {\n          // this element already exists and should not be re-appended, so remove it from\n          // the new content map, preserving it in the DOM\n          srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n          preserved.push(currentHeadElt);\n        }\n      } else {\n        if (ctx.head.style === \"append\") {\n          // we are appending and this existing element is not new content\n          // so if and only if it is marked for re-append do we do anything\n          if (isReAppended) {\n            removed.push(currentHeadElt);\n            nodesToAppend.push(currentHeadElt);\n          }\n        } else {\n          // if this is a merge, we remove this content since it is not in the new head\n          if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n            removed.push(currentHeadElt);\n          }\n        }\n      }\n    }\n\n    // Push the remaining new head elements in the Map into the\n    // nodes to append to the head tag\n    nodesToAppend.push(...srcToNewHeadNodes.values());\n\n    let promises = [];\n    for (const newNode of nodesToAppend) {\n      // TODO: This could theoretically be null, based on type\n      let newElt = /** @type {ChildNode} */ (\n        document.createRange().createContextualFragment(newNode.outerHTML)\n          .firstChild\n      );\n      if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n        if (\n          (\"href\" in newElt && newElt.href) ||\n          (\"src\" in newElt && newElt.src)\n        ) {\n          /** @type {(result?: any) => void} */ let resolve;\n          let promise = new Promise(function (_resolve) {\n            resolve = _resolve;\n          });\n          newElt.addEventListener(\"load\", function () {\n            resolve();\n          });\n          promises.push(promise);\n        }\n        oldHead.appendChild(newElt);\n        ctx.callbacks.afterNodeAdded(newElt);\n        added.push(newElt);\n      }\n    }\n\n    // remove all removed elements, after we have appended the new elements to avoid\n    // additional network requests for things like style sheets\n    for (const removedElement of removed) {\n      if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n        oldHead.removeChild(removedElement);\n        ctx.callbacks.afterNodeRemoved(removedElement);\n      }\n    }\n\n    ctx.head.afterHeadMorphed(oldHead, {\n      added: added,\n      kept: preserved,\n      removed: removed,\n    });\n    return promises;\n  }\n\n  //=============================================================================\n  // Create Morph Context Functions\n  //=============================================================================\n  const createMorphContext = (function () {\n    /**\n     *\n     * @param {Element} oldNode\n     * @param {Element} newContent\n     * @param {Config} config\n     * @returns {MorphContext}\n     */\n    function createMorphContext(oldNode, newContent, config) {\n      const { persistentIds, idMap } = createIdMaps(oldNode, newContent);\n\n      const mergedConfig = mergeDefaults(config);\n      const morphStyle = mergedConfig.morphStyle || \"outerHTML\";\n      if (![\"innerHTML\", \"outerHTML\"].includes(morphStyle)) {\n        throw `Do not understand how to morph style ${morphStyle}`;\n      }\n\n      return {\n        target: oldNode,\n        newContent: newContent,\n        config: mergedConfig,\n        morphStyle: morphStyle,\n        ignoreActive: mergedConfig.ignoreActive,\n        ignoreActiveValue: mergedConfig.ignoreActiveValue,\n        restoreFocus: mergedConfig.restoreFocus,\n        idMap: idMap,\n        persistentIds: persistentIds,\n        pantry: createPantry(),\n        callbacks: mergedConfig.callbacks,\n        head: mergedConfig.head,\n      };\n    }\n\n    /**\n     * Deep merges the config object and the Idiomorph.defaults object to\n     * produce a final configuration object\n     * @param {Config} config\n     * @returns {ConfigInternal}\n     */\n    function mergeDefaults(config) {\n      let finalConfig = Object.assign({}, defaults);\n\n      // copy top level stuff into final config\n      Object.assign(finalConfig, config);\n\n      // copy callbacks into final config (do this to deep merge the callbacks)\n      finalConfig.callbacks = Object.assign(\n        {},\n        defaults.callbacks,\n        config.callbacks,\n      );\n\n      // copy head config into final config  (do this to deep merge the head)\n      finalConfig.head = Object.assign({}, defaults.head, config.head);\n\n      return finalConfig;\n    }\n\n    /**\n     * @returns {HTMLDivElement}\n     */\n    function createPantry() {\n      const pantry = document.createElement(\"div\");\n      pantry.hidden = true;\n      document.body.insertAdjacentElement(\"afterend\", pantry);\n      return pantry;\n    }\n\n    /**\n     * Returns all elements with an ID contained within the root element and its descendants\n     *\n     * @param {Element} root\n     * @returns {Element[]}\n     */\n    function findIdElements(root) {\n      let elements = Array.from(root.querySelectorAll(\"[id]\"));\n      if (root.id) {\n        elements.push(root);\n      }\n      return elements;\n    }\n\n    /**\n     * A bottom-up algorithm that populates a map of Element -> IdSet.\n     * The idSet for a given element is the set of all IDs contained within its subtree.\n     * As an optimzation, we filter these IDs through the given list of persistent IDs,\n     * because we don't need to bother considering IDed elements that won't be in the new content.\n     *\n     * @param {Map<Node, Set<string>>} idMap\n     * @param {Set<string>} persistentIds\n     * @param {Element} root\n     * @param {Element[]} elements\n     */\n    function populateIdMapWithTree(idMap, persistentIds, root, elements) {\n      for (const elt of elements) {\n        if (persistentIds.has(elt.id)) {\n          /** @type {Element|null} */\n          let current = elt;\n          // walk up the parent hierarchy of that element, adding the id\n          // of element to the parent's id set\n          while (current) {\n            let idSet = idMap.get(current);\n            // if the id set doesn't exist, create it and insert it in the map\n            if (idSet == null) {\n              idSet = new Set();\n              idMap.set(current, idSet);\n            }\n            idSet.add(elt.id);\n\n            if (current === root) break;\n            current = current.parentElement;\n          }\n        }\n      }\n    }\n\n    /**\n     * This function computes a map of nodes to all ids contained within that node (inclusive of the\n     * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n     * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n     * to contribute to a parent nodes matching.\n     *\n     * @param {Element} oldContent  the old content that will be morphed\n     * @param {Element} newContent  the new content to morph to\n     * @returns {IdSets}\n     */\n    function createIdMaps(oldContent, newContent) {\n      const oldIdElements = findIdElements(oldContent);\n      const newIdElements = findIdElements(newContent);\n\n      const persistentIds = createPersistentIds(oldIdElements, newIdElements);\n\n      /** @type {Map<Node, Set<string>>} */\n      let idMap = new Map();\n      populateIdMapWithTree(idMap, persistentIds, oldContent, oldIdElements);\n\n      /** @ts-ignore - if newContent is a duck-typed parent, pass its single child node as the root to halt upwards iteration */\n      const newRoot = newContent.__idiomorphRoot || newContent;\n      populateIdMapWithTree(idMap, persistentIds, newRoot, newIdElements);\n\n      return { persistentIds, idMap };\n    }\n\n    /**\n     * This function computes the set of ids that persist between the two contents excluding duplicates\n     *\n     * @param {Element[]} oldIdElements\n     * @param {Element[]} newIdElements\n     * @returns {Set<string>}\n     */\n    function createPersistentIds(oldIdElements, newIdElements) {\n      let duplicateIds = new Set();\n\n      /** @type {Map<string, string>} */\n      let oldIdTagNameMap = new Map();\n      for (const { id, tagName } of oldIdElements) {\n        if (oldIdTagNameMap.has(id)) {\n          duplicateIds.add(id);\n        } else {\n          oldIdTagNameMap.set(id, tagName);\n        }\n      }\n\n      let persistentIds = new Set();\n      for (const { id, tagName } of newIdElements) {\n        if (persistentIds.has(id)) {\n          duplicateIds.add(id);\n        } else if (oldIdTagNameMap.get(id) === tagName) {\n          persistentIds.add(id);\n        }\n        // skip if tag types mismatch because its not possible to morph one tag into another\n      }\n\n      for (const id of duplicateIds) {\n        persistentIds.delete(id);\n      }\n      return persistentIds;\n    }\n\n    return createMorphContext;\n  })();\n\n  //=============================================================================\n  // HTML Normalization Functions\n  //=============================================================================\n  const { normalizeElement, normalizeParent } = (function () {\n    /** @type {WeakSet<Node>} */\n    const generatedByIdiomorph = new WeakSet();\n\n    /**\n     *\n     * @param {Element | Document} content\n     * @returns {Element}\n     */\n    function normalizeElement(content) {\n      if (content instanceof Document) {\n        return content.documentElement;\n      } else {\n        return content;\n      }\n    }\n\n    /**\n     *\n     * @param {null | string | Node | HTMLCollection | Node[] | Document & {generatedByIdiomorph:boolean}} newContent\n     * @returns {Element}\n     */\n    function normalizeParent(newContent) {\n      if (newContent == null) {\n        return document.createElement(\"div\"); // dummy parent element\n      } else if (typeof newContent === \"string\") {\n        return normalizeParent(parseContent(newContent));\n      } else if (\n        generatedByIdiomorph.has(/** @type {Element} */ (newContent))\n      ) {\n        // the template tag created by idiomorph parsing can serve as a dummy parent\n        return /** @type {Element} */ (newContent);\n      } else if (newContent instanceof Node) {\n        if (newContent.parentNode) {\n          // we can't use the parent directly because newContent may have siblings\n          // that we don't want in the morph, and reparenting might be expensive (TODO is it?),\n          // so instead we create a fake parent node that only sees a slice of its children.\n          /** @type {Element} */\n          return /** @type {any} */ (new SlicedParentNode(newContent));\n        } else {\n          // a single node is added as a child to a dummy parent\n          const dummyParent = document.createElement(\"div\");\n          dummyParent.append(newContent);\n          return dummyParent;\n        }\n      } else {\n        // all nodes in the array or HTMLElement collection are consolidated under\n        // a single dummy parent element\n        const dummyParent = document.createElement(\"div\");\n        for (const elt of [...newContent]) {\n          dummyParent.append(elt);\n        }\n        return dummyParent;\n      }\n    }\n\n    /**\n     * A fake duck-typed parent element to wrap a single node, without actually reparenting it.\n     * This is useful because the node may have siblings that we don't want in the morph, and it may also be moved\n     * or replaced with one or more elements during the morph. This class effectively allows us a window into\n     * a slice of a node's children.\n     * \"If it walks like a duck, and quacks like a duck, then it must be a duck!\" -- James Whitcomb Riley (1849\u20131916)\n     */\n    class SlicedParentNode {\n      /** @param {Node} node */\n      constructor(node) {\n        this.originalNode = node;\n        this.realParentNode = /** @type {Element} */ (node.parentNode);\n        this.previousSibling = node.previousSibling;\n        this.nextSibling = node.nextSibling;\n      }\n\n      /** @returns {Node[]} */\n      get childNodes() {\n        // return slice of realParent's current childNodes, based on previousSibling and nextSibling\n        const nodes = [];\n        let cursor = this.previousSibling\n          ? this.previousSibling.nextSibling\n          : this.realParentNode.firstChild;\n        while (cursor && cursor != this.nextSibling) {\n          nodes.push(cursor);\n          cursor = cursor.nextSibling;\n        }\n        return nodes;\n      }\n\n      /**\n       * @param {string} selector\n       * @returns {Element[]}\n       */\n      querySelectorAll(selector) {\n        return this.childNodes.reduce((results, node) => {\n          if (node instanceof Element) {\n            if (node.matches(selector)) results.push(node);\n            const nodeList = node.querySelectorAll(selector);\n            for (let i = 0; i < nodeList.length; i++) {\n              results.push(nodeList[i]);\n            }\n          }\n          return results;\n        }, /** @type {Element[]} */ ([]));\n      }\n\n      /**\n       * @param {Node} node\n       * @param {Node} referenceNode\n       * @returns {Node}\n       */\n      insertBefore(node, referenceNode) {\n        return this.realParentNode.insertBefore(node, referenceNode);\n      }\n\n      /**\n       * @param {Node} node\n       * @param {Node} referenceNode\n       * @returns {Node}\n       */\n      moveBefore(node, referenceNode) {\n        // @ts-ignore - use new moveBefore feature\n        return this.realParentNode.moveBefore(node, referenceNode);\n      }\n\n      /**\n       * for later use with populateIdMapWithTree to halt upwards iteration\n       * @returns {Node}\n       */\n      get __idiomorphRoot() {\n        return this.originalNode;\n      }\n    }\n\n    /**\n     *\n     * @param {string} newContent\n     * @returns {Node | null | DocumentFragment}\n     */\n    function parseContent(newContent) {\n      let parser = new DOMParser();\n\n      // remove svgs to avoid false-positive matches on head, etc.\n      let contentWithSvgsRemoved = newContent.replace(\n        /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n        \"\",\n      );\n\n      // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n      if (\n        contentWithSvgsRemoved.match(/<\\/html>/) ||\n        contentWithSvgsRemoved.match(/<\\/head>/) ||\n        contentWithSvgsRemoved.match(/<\\/body>/)\n      ) {\n        let content = parser.parseFromString(newContent, \"text/html\");\n        // if it is a full HTML document, return the document itself as the parent container\n        if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n          generatedByIdiomorph.add(content);\n          return content;\n        } else {\n          // otherwise return the html element as the parent container\n          let htmlElement = content.firstChild;\n          if (htmlElement) {\n            generatedByIdiomorph.add(htmlElement);\n          }\n          return htmlElement;\n        }\n      } else {\n        // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n        // deal with touchy tags like tr, tbody, etc.\n        let responseDoc = parser.parseFromString(\n          \"<body><template>\" + newContent + \"</template></body>\",\n          \"text/html\",\n        );\n        let content = /** @type {HTMLTemplateElement} */ (\n          responseDoc.body.querySelector(\"template\")\n        ).content;\n        generatedByIdiomorph.add(content);\n        return content;\n      }\n    }\n\n    return { normalizeElement, normalizeParent };\n  })();\n\n  //=============================================================================\n  // This is what ends up becoming the Idiomorph global object\n  //=============================================================================\n  return {\n    morph,\n    defaults,\n  };\n})();\n\nexport {Idiomorph};\n", "import { Idiomorph } from \"idiomorph\";\n\ndeclare global {\n    interface Document {\n        rxMutationObserver: MutationObserver\n    }\n\n    interface HTMLElement {\n        dataset: {\n            rxIgnore?: string, //data-rx-ignore\n            rxAction?: string, //data-rx-action\n            rxMethod?: string, //data-rx-method\n            rxTrigger?: string, //data-rx-trigger\n            rxDisableInFlight?: string, //data-rx-disable-in-flight\n            rxDebounce?: string //data-rx-debounce\n        },\n        addRxCallbacks?: (callbacks: ElementCallbacks) => void,\n        _rxCallbacks?: ElementCallbacks,\n    }\n}\n\nexport type RazorX = {\n    init: (options?: Options) => void,\n    addCallbacks: (callbacks: DocumentCallbacks) => void,\n}\n\nexport type Options = {\n    addCookieToRequestHeader?: string | string[],\n    encodeRequestFormDataAsJson?: boolean, //true\n}\n\nexport type DocumentCallbacks = {\n    beforeDocumentProcessed?: () => void,\n    afterDocumentProcessed?: () => void,\n    beforeInitializeElement?: (element: HTMLElement) => boolean, //return false to cancel\n    afterInitializeElement?: (element: HTMLElement) => void, //return false to cancel\n    beforeFetch?: (triggerElement: HTMLElement, requestConfiguration: RequestConfiguration) => void, \n    afterFetch?: (triggerElement: HTMLElement, requestDetail: RequestDetail, response: Response) => void,\n    beforeDocumentUpdate?: (triggerElement: HTMLElement, mergeElement: HTMLElement, strategy: MergeStrategyType) => boolean,\n    afterDocumentUpdate?: (triggerElement: HTMLElement) => void\n    onElementAdded?: (addedElement: HTMLElement) => void,\n    onElementMorphed?: (morphedElement: HTMLElement) => void,\n    onElementRemoved?: (removedElement: HTMLElement) => void,\n    onElementTriggerError?: (triggerElement: HTMLElement, error: unknown) => void,\n}\n\nexport type ElementCallbacks = {\n    beforeFetch?: (requestConfiguration: RequestConfiguration) => void, \n    afterFetch?: (requestDetail: RequestDetail, response: Response) => void,\n    beforeDocumentUpdate?: (mergeElement: HTMLElement, strategy: MergeStrategyType) => boolean,\n    afterDocumentUpdate?: () => void,\n    onElementTriggerError?: (error: unknown) => void,\n}\n\nexport type RequestConfiguration = {\n    trigger: Event,\n    action: string,\n    method: HttpMethod,\n    headers: Headers,\n    body: FormData | string,\n    abort: (reason?: string) => void\n}\n\nexport type RequestDetail = {\n    action: string,\n    method: HttpMethod,\n    redirect: FetchRedirect,\n    body: FormData | string,\n    headers: Headers,\n    signal: AbortSignal,\n}\n\nexport type MergeStrategy = {\n    target: string,\n    strategy: MergeStrategyType\n}\n\nexport type HttpMethod = \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\n\nexport type FetchRedirect = \"follow\" | \"error\" | \"manual\";\n\nexport type MergeStrategyType = \"swap\" | \"afterbegin\" | \"afterend\" | \"beforebegin\" | \"beforeend\" | \"morph\" | \"remove\";\n\nexport const RxRequestHeader = \"rx-request\";\n\nexport enum RxResponseHeaders {\n    Merge = \"rx-merge\",\n    MorphIgnoreActive = \"rx-morph-ignore-active\"\n}\n\nconst _processedScriptTag = \"data-rx-script-processed\";\n\nconst _requestRefTracker: Set<string> = new Set();\n\nconst _debouncedRequests: Map<string, (ele: HTMLElement, evt: Event) => Promise<void>> = new Map();\n\nconst _fetchRedirect: FetchRedirect = \"follow\";\n\nconst _callbacks: DocumentCallbacks = {};\n\nconst _isFirefox = navigator.userAgent.toLowerCase().includes(\"firefox\");\n\nconst _addCallbacks = (callbacks: DocumentCallbacks) => {\n    _callbacks.afterDocumentProcessed = callbacks.afterDocumentProcessed;\n    _callbacks.afterDocumentUpdate = callbacks.afterDocumentUpdate;\n    _callbacks.afterFetch = callbacks.afterFetch;\n    _callbacks.afterInitializeElement = callbacks.afterInitializeElement;\n    _callbacks.beforeDocumentProcessed = callbacks.beforeDocumentProcessed;\n    _callbacks.beforeDocumentUpdate = callbacks.beforeDocumentUpdate;\n    _callbacks.beforeFetch = callbacks.beforeFetch;\n    _callbacks.beforeInitializeElement = callbacks.beforeInitializeElement;\n    _callbacks.onElementAdded = callbacks.onElementAdded;\n    _callbacks.onElementMorphed = callbacks.onElementMorphed;\n    _callbacks.onElementRemoved = callbacks.onElementRemoved;\n    _callbacks.onElementTriggerError = callbacks.onElementTriggerError;\n}\n\nconst _init = (options?: Options, callbacks?: DocumentCallbacks): void => {\n\n    if (document.rxMutationObserver) {\n        //already initialized\n        return;\n    }\n\n    if (callbacks) {\n        _addCallbacks(callbacks);\n    }\n\n    document.rxMutationObserver = new MutationObserver(recs => {\n        recs.forEach(rec => {\n            if (rec.type !== \"childList\") {\n                return;\n            }\n            rec.removedNodes.forEach(node => { \n                if (!(node instanceof HTMLElement)) {\n                    return;\n                }\n                removeTriggers(node);\n                if (_callbacks.onElementRemoved) {\n                    _callbacks.onElementRemoved(node);\n                }\n            });\n            rec.addedNodes.forEach(node => { \n                if (!(node instanceof HTMLElement)) {\n                    return;\n                }\n                normalizeScriptTags(node);\n                addTriggers(node);\n                if (_callbacks.onElementAdded) {\n                    _callbacks.onElementAdded(node);\n                }\n            });\n        });\n    });\n    \n    document.addEventListener(\"DOMContentLoaded\", DOMContentLoaded);\n\n    function getMethod(ele: HTMLElement): HttpMethod {\n        const m = ele.dataset.rxMethod?.trim().toUpperCase() ?? \"\";\n        switch (m) {\n            case \"\":\n            case \"GET\":\n                return \"GET\";\n            case \"POST\": \n            case \"PUT\":\n            case \"PATCH\":\n            case \"DELETE\":\n                return m;\n            default: { \n                const err = `${m} is not a valid HTTP method.`;\n                sendError(ele, err);\n                throw new Error(err); \n            }\n        }\n    }\n\n    function sendError(ele: HTMLElement, err: unknown): void {\n        if (ele._rxCallbacks!.onElementTriggerError) {\n            ele._rxCallbacks!.onElementTriggerError(err);\n        }\n        if (_callbacks.onElementTriggerError) {\n            _callbacks.onElementTriggerError(ele, err);\n        }\n        console.error(err);\n    }\n\n    function toggleDisable(ele: HTMLElement, disable: boolean = false) {\n        let targetElement: HTMLElement | null = null;\n        const parentFieldset = ele.closest(\"fieldset\");\n        if (parentFieldset) {\n            targetElement = parentFieldset;\n        } else if (ele instanceof HTMLOptionElement) {\n            const parentOptGroup = ele.closest(\"optgroup\");\n            if (parentOptGroup) {\n                targetElement = parentOptGroup;\n            } else {\n                targetElement = ele;\n            }\n        } else if (ele instanceof HTMLInputElement\n            || ele instanceof HTMLTextAreaElement\n            || ele instanceof HTMLSelectElement\n            || ele instanceof HTMLButtonElement) {\n            targetElement = ele;\n        }\n        if (targetElement) {\n            if (disable) {\n                targetElement.setAttribute(\"disabled\", \"\");\n            } else {\n                targetElement.removeAttribute(\"disabled\");\n                //targetElement.focus();\n            }\n        }\n    }\n\n    function debounce(func: (ele: HTMLElement, evt: Event) => Promise<void>, delay: number): (ele: HTMLElement, evt: Event) => Promise<void> {\n        let timeoutId: number | null = null;\n        let pending: Array<{ \n            resolve: (value: void) => void; \n            reject: (reason?: unknown) => void \n        }> = [];\n        return (ele: HTMLElement, evt: Event): Promise<void> => {\n            return new Promise((resolve, reject) => {\n                if (timeoutId) {\n                    clearTimeout(timeoutId);\n                }\n                pending.push({ resolve, reject });\n                timeoutId = setTimeout(() => {\n                    timeoutId = null;\n                    Promise.resolve(func(ele, evt))\n                        .then((result) => {\n                            pending.forEach(({ resolve: res }) => res(result)); \n                        })\n                        .catch((error: unknown) => {\n                            pending.forEach(({ reject: rej }) => rej(error));\n                        })\n                        .finally(() => {\n                            pending = []; \n                        });\n                }, delay);\n            });\n        };\n    }\n\n\n    async function elementTriggerEventHandler(this: HTMLElement, evt: Event): Promise<void> {\n        //TODO: is request queueing also needed?\n        if (!this.dataset.rxDebounce) {\n            await elementTriggerProcessor(this, evt);\n            return;\n        }\n        const delay = parseInt(this.dataset.rxDebounce, 10);\n        if (Number.isNaN(delay) || delay <= 0) {\n            throw new Error(`Element ${this.id} data-rx-debounce attribute value must be a valid number greater than zero.`);\n        }\n        let debounceElementTrigger = _debouncedRequests.get(this.id);\n        if (debounceElementTrigger) {\n            await debounceElementTrigger(this, evt);\n        } else {\n            debounceElementTrigger = debounce(elementTriggerProcessor, delay);\n            _debouncedRequests.set(this.id, debounceElementTrigger);\n            await debounceElementTrigger(this, evt);\n        }\n    }\n\n    async function elementTriggerProcessor(ele: HTMLElement, evt: Event): Promise<void> {\n        evt.preventDefault();\n        try {   \n            _debouncedRequests.delete(ele.id);\n            if (_requestRefTracker.has(ele.id)) {\n                throw new Error(`Element ${ele.id} is already executing a request.`);\n            }\n            let form: HTMLFormElement | null = null;\n            if (\"form\" in ele && ele.form instanceof HTMLFormElement) {\n                form = ele.form; \n            }\n            if (!form) {\n                form = ele.closest(\"form\");\n            }\n            const body = new FormData(form ?? undefined, evt instanceof SubmitEvent ? evt.submitter : null);\n            if (!form && \"name\" in ele && \"value\" in ele && typeof ele.name === \"string\" && typeof ele.value === \"string\") {\n                body.append(ele.name, ele.value);\n            }\n            const headers = new Headers();\n            headers.set(RxRequestHeader, \"\");\n            const ac = new AbortController();\n            const request: RequestDetail = {\n                action: ele.dataset.rxAction ?? \"\", \n                method: getMethod(ele),\n                redirect: _fetchRedirect,\n                body,\n                headers: headers,\n                signal: ac.signal,\n            };\n            if (options?.addCookieToRequestHeader) {\n                if (Array.isArray(options.addCookieToRequestHeader)) {\n                    options.addCookieToRequestHeader.forEach(cookie => {\n                        addCookieToRequest(request, cookie);\n                    });\n                } else {\n                    addCookieToRequest(request, options.addCookieToRequestHeader);\n                }\n            }\n            if (options?.encodeRequestFormDataAsJson === undefined\n                || options.encodeRequestFormDataAsJson === true) {\n                encodeBodyAsJson(request);\n            }\n            if (/GET|DELETE/.test(request.method!)) {\n                const params = new URLSearchParams(request.body! as unknown as Record<string, string>);\n                if (params.size) {\n                    request.action += (/\\?/.test(request.action!) ? \"&\" : \"?\") + params;\n                }\n                request.body = \"\";\n            }\n            const config: RequestConfiguration = {\n                trigger: evt,\n                action: request.action,\n                method: request.method,\n                body: request.body,\n                headers: request.headers,\n                abort: ac.abort.bind(ac),\n            }\n            _requestRefTracker.add(ele.id);\n            const disableElement = ele.dataset.rxDisableInFlight ?? null;\n            let response: Response | null = null;\n            try {\n                if (disableElement !== null && disableElement.toLowerCase() !== \"false\") {\n                    toggleDisable(ele, true);\n                }\n                if (ele._rxCallbacks!.beforeFetch) {\n                    ele._rxCallbacks!.beforeFetch(config);\n                }\n                if (_callbacks.beforeFetch) {\n                    _callbacks.beforeFetch(ele, config);\n                }\n                if (ac.signal.aborted) {\n                    return;\n                }\n                response = await fetch(request.action, request);\n                if (ac.signal.aborted) {\n                    return;\n                }\n                if (ele._rxCallbacks!.afterFetch) {\n                    ele._rxCallbacks!.afterFetch(request, response);\n                }\n                if (_callbacks.afterFetch) {\n                    _callbacks.afterFetch(ele, request, response);\n                }\n            } catch(error: unknown) {\n                sendError(ele, error);\n            } finally {\n                _requestRefTracker.delete(ele.id);\n                if (disableElement !== null && disableElement.toLowerCase() !== \"false\") {\n                    toggleDisable(ele, false);\n                }\n            }\n            if (!response) {\n                sendError(ele, `Element ${ele.id} has no response after request.`);\n                return;\n            }\n            if (response.status === 202) {\n                //used to issue a follow-up GET request for rendering\n                const location = response.headers.get(\"location\");\n                if (location && location.trim() !== \"\") {\n                    window.location.replace(location);\n                }\n                return; \n            }\n            if (response.status === 204) {\n                //skip response merge \n                return;\n            }\n            if (response.status >= 400) {\n                //dev error response\n                document.rxMutationObserver?.disconnect();\n                removeTriggers(document.body);\n                document.head.innerHTML = \"<title>Error</title>\";\n                const contentType = response.headers.get(\"content-type\");\n                if (contentType && (contentType.includes(\"application/json\") || contentType.includes(\"application/problem+json\"))) {\n                    const formattedJson = JSON.stringify(await response.json(), null, 2); \n                    document.body.innerHTML = `<pre><code>${formattedJson}</code></pre>`;\t\t\t\t\n                } else {\n                    document.body.innerText = await response.text();\n                }\n                return;\n            }\n            if (document.startViewTransition !== undefined) {\n                await document.startViewTransition(async () => await mergeFragments(ele, response)).finished;\n            } else {\n                await mergeFragments(ele, response);\n            }\n            if (ele._rxCallbacks!.afterDocumentUpdate) {\n                ele._rxCallbacks!.afterDocumentUpdate();\n            }\n            if (_callbacks.afterDocumentUpdate) {\n                _callbacks.afterDocumentUpdate(ele);\n            }\n        } catch(error: unknown) {\n            sendError(ele, error);\n        } \n    } \n\n    function processScript(script: HTMLScriptElement): void {\n        if (script.hasAttribute(_processedScriptTag)) {\n            script.removeAttribute(_processedScriptTag);\n            return;\n        }\n        const newScript = document.createElement(\"script\");\n        Array.from(script.attributes).forEach(attr => {\n            newScript.setAttribute(attr.name, attr.value);\n        });\n        newScript.setAttribute(_processedScriptTag, \"\");\n        newScript.textContent = script.textContent;\n        newScript.async = false;\n        const parent = script.parentNode;\n        parent?.insertBefore(newScript, script);\n        script.remove();\n    }\n\n    function normalizeScriptTags(fragment: HTMLElement): void {\n        if (!_isFirefox) {\n            return;\n        }\n        if (fragment instanceof HTMLScriptElement) {\n            processScript(fragment);\n            return;\n        }\n        Array.from(fragment.querySelectorAll(\"script\")).forEach(script => {\n            processScript(script);\n        });\n    }\n\n    function getFragment(fragments: ChildNode[], mergeStrategy: MergeStrategy): HTMLTemplateElement | undefined {\n        const fragmentId = `${mergeStrategy.target}-fragment`;\n        const fragment = fragments.find(f => f instanceof HTMLTemplateElement && f.id === fragmentId) as HTMLTemplateElement | undefined;\n        if (!fragment) {\n            throw new Error(`Expected a response body fragment with id=\"${fragmentId}\"`);\n        }\n        if (!fragment.hasChildNodes) {\n            throw new Error(`Expected one or more child elements in fragment with id=\"${fragmentId}\"`);\n        }\n        return fragment;\n    }\n\n    function getTarget(triggerElement: HTMLElement, fragment: HTMLTemplateElement, mergeStrategy: MergeStrategy): HTMLElement | undefined {\n        const target = document.getElementById(mergeStrategy.target);\n        if (!target) {\n            throw new Error(`Expected an HTML element with id=\"${mergeStrategy.target}\"`);\n        }\n        if (triggerElement._rxCallbacks!.beforeDocumentUpdate && triggerElement._rxCallbacks!.beforeDocumentUpdate(fragment, mergeStrategy.strategy) === false) {\n            return;\n        }\n        if (_callbacks.beforeDocumentUpdate && _callbacks.beforeDocumentUpdate(triggerElement, fragment, mergeStrategy.strategy) === false) {\n            return;\n        }\n        return target;\n    }\n\n    async function mergeFragments(triggerElement: HTMLElement, response: Response): Promise<void> {\n        const merge = response?.headers.get(RxResponseHeaders.Merge);\n        if (!merge) {\n            throw new Error(`Expected a \"${RxResponseHeaders.Merge}\" header object.`);\n        }\n        const mergeStrategyArray: MergeStrategy[] = JSON.parse(merge);\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(\"<body><template>\" + await response.text() + \"</template></body>\", \"text/html\");\n        const template = doc.body.querySelector(\"template\")?.content;\n        const fragments = Array.from(template?.childNodes ?? []);\n        const swaps = mergeStrategyArray.filter(s => {\n            if (s.strategy === \"swap\" \n                || s.strategy === \"afterbegin\"\n                || s.strategy === \"afterend\"\n                || s.strategy === \"beforebegin\"\n                || s.strategy === \"beforeend\") {\n                return true;\n            }\n            return false;\n        });\n        swaps.forEach(s => {\n            const fragment = getFragment(fragments, s);\n            if (!fragment) {\n                return;\n            }\n            const target = getTarget(triggerElement, fragment, s);\n            if (!target) {\n                return;\n            }\n            if (s.strategy === \"swap\") {\n                target.replaceWith(fragment.content);\n            } else {\n                const newContent = Array.from(fragment.content.children);\n                if (newContent.length === 0) {\n                    return;\n                }\n                //insert the first element based on the strategy\n                target.insertAdjacentElement(s.strategy as InsertPosition, newContent[0]);\n                let thisEle = newContent[0];\n                //insert the remainder afterend of the previous element\n                for (let i = 1; i < newContent.length; i++) {\n                    thisEle.insertAdjacentElement(\"afterend\", newContent[i]);\n                    thisEle = newContent[i];\n                }\n            }\n        });\n        const morphs = mergeStrategyArray.filter(s => s.strategy === \"morph\");\n        morphs.forEach(s => {\n            const fragment = getFragment(fragments, s);\n            if (!fragment) {\n                return;\n            }\n            const target = getTarget(triggerElement, fragment, s);\n            if (!target) {\n                return;\n            }\n            const ignoreActive = response?.headers.has(RxResponseHeaders.MorphIgnoreActive);\n            Idiomorph.morph(target, Array.from(fragment.content.children), { \n                morphStyle: \"outerHTML\", \n                ignoreActiveValue: ignoreActive,\n            })?.forEach(n => {\n                if (!(n instanceof HTMLElement)) {\n                    return;\n                }\n                //TODO: EDGE CASE - what if the data-rx-trigger attribute is morphed?\n                //addTriggers(node);\n                if (_callbacks.onElementMorphed) {\n                    _callbacks.onElementMorphed(n);\n                }\n            });\n        });\n        const removals = mergeStrategyArray.filter(s => s.strategy === \"remove\");\n        removals.forEach(r => {\n            const target = document.getElementById(r.target);\n            if (!target) {\n                return;\n            }\n            if (triggerElement._rxCallbacks!.beforeDocumentUpdate && triggerElement._rxCallbacks!.beforeDocumentUpdate(target, r.strategy) === false) {\n                return;\n            }\n            if (_callbacks.beforeDocumentUpdate && _callbacks.beforeDocumentUpdate(triggerElement, target, r.strategy) === false) {\n                return;\n            }\n            target.remove();\n        });\n    }\n\n    function addCookieToRequest(detail: RequestDetail, cookie: string): void {\n        const value = `; ${document.cookie}`;\n        const parts = value.split(`; ${cookie}=`);\n        if (parts.length !== 2) {\n            return;\n        }\n        if (!detail.headers) {\n            return;\n        }\n        detail.headers.set(`${cookie}`, parts.pop()!.split(\";\").shift() ?? \"\");\n    }\n\n    function encodeBodyAsJson(detail: RequestDetail): void {\n        detail.headers?.set(\"Content-Type\", \"application/json\");\n        if (!(detail.body instanceof FormData)) {\n            return;\n        }\n        const object: Record<string, string | string[]> = {};\n        detail.body?.forEach((value: FormDataEntryValue, key: string) => {\n            if (value instanceof Blob) {\n                //skip any input [type=file] for XMLHttpRequest processing\n                return;\n            }\n            if (Object.hasOwn(object, key)) {\n                if (!Array.isArray(object[key])) {\n                    object[key] = [object[key]];\n                }\n                object[key].push(value);\n            } else {\n                object[key] = value;\n            }\n        })\n        detail.body = JSON.stringify(object);\n    }\n\n    function DOMContentLoaded(): void {\n        //observe the whole document for changes\n        document.rxMutationObserver.observe(document.documentElement, { childList: true, subtree: true });\n        if (_callbacks.beforeDocumentProcessed) {\n            _callbacks.beforeDocumentProcessed();\n        }\n        //process the entire document recursively\n        addTriggers(document.body);\n        if (_callbacks.afterDocumentProcessed) {\n            _callbacks.afterDocumentProcessed();\n        }\n    }\n\n    function addTriggers(ele: HTMLElement) {\n        const firstIgnore = ele.closest(\"[data-rx-ignore]\");\n        if (firstIgnore && firstIgnore instanceof HTMLElement && firstIgnore.dataset.rxIgnore?.toLowerCase() !== \"false\") {\n            return;\n        }\n        //if (ele.matches(`[${RxAttributes.Action}]`)) {\n        if (ele.dataset.rxAction) {\n            let initializeElement = true;\n            if (_callbacks.beforeInitializeElement) {\n                initializeElement = _callbacks.beforeInitializeElement(ele);\n            }\n            if (initializeElement) {\n                if (!ele.id || ele.id.trim() === \"\") {\n                    const err = `Element with \"data-rx-action\" must have a unique ID.`;\n                    throw new Error(err);\n                }\n                //enforce the existence of the element rxTrigger, addRxCallbacks() and _rxCallbacks properties\n                const elementCallbacks: ElementCallbacks = {};\n                const addCallbacks = (callbacks: ElementCallbacks): void => {\n                    elementCallbacks.afterDocumentUpdate = callbacks.afterDocumentUpdate;\n                    elementCallbacks.afterFetch = callbacks.afterFetch;\n                    elementCallbacks.beforeDocumentUpdate = callbacks.beforeDocumentUpdate;\n                    elementCallbacks.beforeFetch = callbacks.beforeFetch;\n                    elementCallbacks.onElementTriggerError = callbacks.onElementTriggerError;\n                }\n                Object.defineProperty(ele, \"addRxCallbacks\", {\n                    value: addCallbacks,\n                    writable: false,\n                });\n                Object.defineProperty(ele, \"_rxCallbacks\", {\n                    value: elementCallbacks,\n                    writable: false,\n                });\n                let rxTrigger = ele.dataset.rxTrigger;\n                //TODO: allow multiple triggers -e.g., \"click keydown\"\n                if (!rxTrigger) {\n                    rxTrigger = ele.matches(\"form\")\n                        ? \"submit\" \n                        : ele.matches(\"input:not([type=button]),select,textarea\") ? \"change\" : \"click\";\n                    ele.setAttribute(\"data-rx-trigger\", rxTrigger);\n                }\n                //id is required and mustn't be modified\n                Object.freeze(ele.id);\n                ele.addEventListener(ele.dataset.rxTrigger!, elementTriggerEventHandler);\n                if (_callbacks.afterInitializeElement) {\n                    _callbacks.afterInitializeElement(ele);\n                }\n            }\n        }\n        const children = ele.children;\n        if (children?.length <= 0) {\n            return;\n        } \n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            if (child instanceof HTMLElement) {\n                addTriggers(child);\n            }\n        }\n    }\n\n    function removeTriggers(ele: HTMLElement) {\n        if (ele.dataset.rxTrigger) {\t\n            //remove the event handler reference\n            ele.removeEventListener(ele.dataset.rxTrigger, elementTriggerEventHandler);\n        }\n        const children = ele.children;\n        if (children?.length <= 0) {\n            return;\n        } \n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            if (child instanceof HTMLElement) {\n                removeTriggers(child);\n            }\n        }\n    }\n}\n\nconst razorxProto: unknown = {\n    init: Object.freeze(_init),\n    addCallbacks: Object.freeze(_addCallbacks)\n}\n\nexport const razorx = razorxProto as RazorX;"],
  "mappings": "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",
  "names": ["Idiomorph", "noOp", "defaults", "elt", "morph", "oldNode", "newContent", "config", "normalizeElement", "newNode", "normalizeParent", "ctx", "createMorphContext", "morphedNodes", "saveAndRestoreFocus", "withHeadBlocking", "morphChildren", "morphOuterHTML", "oldParent", "fn", "activeElement", "activeElementId", "selectionStart", "selectionEnd", "results", "newParent", "insertionPoint", "endPoint", "newChild", "bestMatch", "findBestMatch", "removeNodesBetween", "morphNode", "movedChild", "moveBeforeById", "insertedNode", "createNode", "tempNode", "removeNode", "newEmptyChild", "newClonedChild", "node", "startPoint", "softMatch", "nextSibling", "siblingSoftMatchCount", "cursor", "isSoftMatch", "isIdSetMatch", "oldSet", "newSet", "id", "oldElt", "newElt", "moveBefore", "startInclusive", "endExclusive", "parentNode", "after", "target", "removeElementFromAncestorsIdMaps", "element", "idSet", "handleHeadElement", "morphAttributes", "ignoreValueOfActiveElement", "type", "oldAttributes", "newAttributes", "newAttribute", "ignoreAttribute", "i", "oldAttribute", "syncInputValue", "oldElement", "newElement", "newValue", "oldValue", "syncBooleanAttribute", "attributeName", "newLiveValue", "oldLiveValue", "ignoreUpdate", "attr", "updateType", "possibleActiveElement", "callback", "oldHead", "newHead", "promises", "newCtx", "added", "removed", "preserved", "nodesToAppend", "srcToNewHeadNodes", "newHeadChild", "currentHeadElt", "inNewContent", "isReAppended", "isPreserved", "resolve", "promise", "_resolve", "removedElement", "persistentIds", "idMap", "createIdMaps", "mergedConfig", "mergeDefaults", "morphStyle", "createPantry", "finalConfig", "pantry", "findIdElements", "root", "elements", "populateIdMapWithTree", "current", "oldContent", "oldIdElements", "newIdElements", "createPersistentIds", "newRoot", "duplicateIds", "oldIdTagNameMap", "tagName", "generatedByIdiomorph", "content", "parseContent", "SlicedParentNode", "dummyParent", "nodes", "selector", "nodeList", "referenceNode", "parser", "contentWithSvgsRemoved", "htmlElement", "RxRequestHeader", "RxResponseHeaders", "_processedScriptTag", "_requestRefTracker", "_debouncedRequests", "_fetchRedirect", "_callbacks", "_isFirefox", "_addCallbacks", "callbacks", "_init", "options", "recs", "rec", "node", "removeTriggers", "normalizeScriptTags", "addTriggers", "DOMContentLoaded", "getMethod", "ele", "m", "err", "sendError", "toggleDisable", "disable", "targetElement", "parentFieldset", "parentOptGroup", "debounce", "func", "delay", "timeoutId", "pending", "evt", "resolve", "reject", "result", "res", "error", "rej", "elementTriggerEventHandler", "elementTriggerProcessor", "debounceElementTrigger", "form", "body", "headers", "ac", "request", "cookie", "addCookieToRequest", "encodeBodyAsJson", "params", "config", "disableElement", "response", "location", "contentType", "formattedJson", "mergeFragments", "processScript", "script", "newScript", "attr", "fragment", "getFragment", "fragments", "mergeStrategy", "fragmentId", "f", "getTarget", "triggerElement", "target", "merge", "mergeStrategyArray", "template", "s", "newContent", "thisEle", "i", "ignoreActive", "Idiomorph", "n", "r", "detail", "parts", "object", "value", "key", "firstIgnore", "initializeElement", "elementCallbacks", "rxTrigger", "children", "child", "razorxProto", "razorx"]
}
